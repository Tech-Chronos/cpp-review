##  4.18 -9 （内存管理）

1.    char ch[8] = “abcd”; 与 const char* ptr = “abcd” 内存布局对比

2.    sizeof 数组表示数组的大小，sizeof指针就是指针本身大小，4 or 8

3.    calloc 和 malloc 区别

4.   realloc 原地扩容和异地扩容

5.    new 的语法格式和 特性
      -   可以初始化，用(),多个用{}

      -   自定义类型 开空间 + 构造函数

      -   ```cpp
          ListNode* CreateList(int n)
          {
              ListNode head(-1);
              ListNode* tail = &head;
              int val;
              printf("请依次输入%d个节点的值：>", n);
              for (size_t i = 0; i < n; ++i)
              {
                  cin >> val;
                  tail->next = new ListNode(val);
                  tail =  tail->next;
              }
              return head._next;
          }
          ```

          

      -   失败抛异常（和malloc不同）

      -   operator new & operator delete

          -   new 底层调用的 operator new，delete 类似
          -   区别是 失败抛异常，不会返回空
          -   第二点是对自定义类型调用它的构造函数
          -   delete 先调用析构，后调用free，否则会内存泄漏

      -   对于new 了多个对象，operator new[]会在底层 在这些空间的前面加上一个四字节的空间（整数）用来存放开辟了多少个这样的空间，给delete析构的时候用（前提是如果自定义类型有析构），内置类型不会这样做

      -    如果自定义类型有析构函数，delete的时候没有加[],可能会报错，因为不知道释放的位置是哪里，因为前面那个整形类型

6.    **placement new(定位new)**

      -   **给已经开辟出来的空间进行初始化（构造函数）**

      -   **内存池中取出空间一般没有初始化，一般用到定位new**
      -   **释放的时候也要显示调用析构函数，还给内存池**

7.    new/delete 和 malloc/free 的区别

8.    内存泄漏

---

### **1. `char ch[8] = "abcd";` 与 `const char\* ptr = "abcd";` 内存布局对比**

#### **内存结构图解**

#### **关键区别**

| **特性**       | `char ch[8] = "abcd";`    | `const char* ptr = "abcd";`      |
| -------------- | ------------------------- | -------------------------------- |
| **存储位置**   | 栈区                      | 指针变量在栈区，字符串在常量区   |
| **可修改性**   | 可修改数组内容            | 字符串内容不可修改（未定义行为） |
| **内存大小**   | `sizeof(ch) = 8`          | `sizeof(ptr) = 4或8`（指针大小） |
| **字符串结尾** | 自动补 `\0`，总长度需预留 | 隐式包含 `\0`                    |

#### **补充**

-   **常量区字符串**：`const char*` 指向的字符串可能被编译器优化为共享存储。

------

### **2. `sizeof` 对数组和指针的区别**

#### **规则**

-   **数组**：`sizeof(arr)` 返回数组总字节大小（元素数 × 元素大小）。
-   **指针**：`sizeof(ptr)` 返回指针变量的大小（32位系统为4，64位系统为8）。

#### **示例**

<CPP>

```cpp
int arr[5];
int* ptr = arr;
cout << sizeof(arr); // 输出 20（假设 int 为4字节）
cout << sizeof(ptr); // 输出4或8
```

#### **陷阱**

-   数组退化为指针

    ：当数组作为函数参数传递时，退化为指针：

    <CPP>

    ```cpp
    void func(int arr[]) {
        cout << sizeof(arr); // 输出指针大小（4或8）
    }
    ```

------

### **3. `calloc` 与 `malloc` 区别**

| **特性**     | `malloc`                 | `calloc`             |
| ------------ | ------------------------ | -------------------- |
| **初始化**   | 不初始化内存内容         | 内存初始化为0        |
| **参数**     | `malloc(size)`           | `calloc(num, size)`  |
| **性能**     | 更快（无初始化开销）     | 较慢（需要清零内存） |
| **适用场景** | 需要随机初始化的内存分配 | 需要清零的安全初始化 |

------

### **4. `realloc` 的原地扩容与异地扩容**

#### **规则**

-   **原地扩容**：若原有内存块后有足够连续空间，直接扩展。
-   **异地扩容**：若空间不足，分配新内存块并复制数据，释放旧内存。

#### **示例**

<CPP>

```cpp
int* ptr = (int*)malloc(4 * sizeof(int));
ptr = (int*)realloc(ptr, 8 * sizeof(int)); // 可能原地或异地扩容
```

------

### **5. `new` 的语法与特性**

#### **基本语法**

<CPP>

```cpp
// 单个对象
int* p1 = new int(10);        // 初始化值为10
MyClass* obj = new MyClass(); // 调用默认构造函数
// 数组
int* arr = new int[5]{1,2,3}; // 前3个元素初始化为1,2,3，其余为0
```

#### **核心特性**

1.  内存分配 + 构造函数调用：new操作分为两步：
    -   调用 `operator new` 分配内存。
    -   调用构造函数初始化对象。
2.  **异常机制**：失败时抛出 `std::bad_alloc`（而非返回 `nullptr`）。
3.  数组处理：
    -   若自定义类型有自己实现的析构函数，`new[]` 在内存头部存储元素个数（用于 `delete[]` 正确析构）。
    -   内置类型无此机制。

#### **底层原理**

<CPP>

```cpp
// new 的底层实现伪代码
void* operator new(size_t size) {
    void* ptr = malloc(size);
    if (ptr == nullptr) throw bad_alloc();
    return ptr;
}
// delete 的底层实现伪代码
void operator delete(void* ptr) {
    free(ptr);
}
```

#### **注意事项**

-   **配对使用**：`new` 必须对应 `delete`，`new[]` 对应 `delete[]`。
-   **未匹配的后果**：若自定义类型有析构函数，未使用 `delete[]` 会导致内存泄漏或崩溃。

------

### **6. \**Placement New（定位new）\****

#### **作用**：在已分配的内存上构造对象。

#### **语法**：

<CPP>

```cpp
#include <new>
char buffer[sizeof(MyClass)]; // 预分配内存
MyClass* obj = new (buffer) MyClass(); // 在 buffer 上构造对象
obj->~MyClass(); // 显式调用析构函数（不释放内存）
```

#### **典型应用**：内存池、避免频繁内存分配。

------

### **7. `new/delete` 与 `malloc/free` 对比**

| **特性**      | `new/delete`             | `malloc/free`            |
| ------------- | ------------------------ | ------------------------ |
| **类型安全**  | 自动计算大小，类型匹配   | 需手动指定大小（字节数） |
| **构造/析构** | 调用构造函数/析构函数    | 仅分配/释放内存          |
| **失败处理**  | 抛出异常                 | 返回 `NULL`              |
| **重载**      | 可重载 `operator new`    | 不可重载                 |
| **初始化**    | 支持 `()` 和 `{}` 初始化 | 无初始化机制             |

------

### **8. 内存泄漏**

#### **定义**：已分配的内存未能正确释放，导致程序持续占用内存。

#### **常见原因**：

1.  **未配对释放**：`new` 未对应 `delete`，`malloc` 未对应 `free`。
2.  **异常中断**：在 `new` 和 `delete` 之间发生异常。
3.  **循环引用**：对象间相互引用，无法自动释放（需弱指针或手动管理）。
4.  **容器未清空**：动态容器（如 `vector`）存储指针未释放。

#### **检测工具**：

-   **Valgrind**：动态分析工具，检测内存泄漏和越界访问。
-   **智能指针**：`std::unique_ptr`、`std::shared_ptr` 自动管理生命周期。