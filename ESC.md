### **1. 预处理阶段（Preprocessing）**

**输入**：`.c` / `.cpp` 源码文件
**输出**：预处理后的 `.i` 文件（文本文件） 

**工具**：预处理器（如 `cpp`）
**核心任务**：

-   **删除注释**：移除所有 `//` 和 `/* ... */` 注释。

-   **宏替换**（Macro Expansion）：展开#define定义的宏。

    

    ```C
    #define PI 3.1415float area = PI * r * r; // 替换为 float area = 3.1415 * r * r;
    ```

-   **文件包含**（File Inclusion）：将#include的头文件内容插入到源文件中。

    

    ```C
    #include <stdio.h>  // 插入 stdio.h 的内容
    ```

-   **条件编译**（Conditional Compilation）：根据#ifdef、#if等指令选择性地保留或删除代码块。

    

    ```C
    #ifdef DEBUGprintf("Debug mode"); // 仅在定义了 DEBUG 时保留#endif
    ```

-   **特殊指令处理**：如 `#pragma`（编译器特定功能）、`#line`（调整行号）等。

**示例**：

```BASH
gcc -E main.c -o main.i  # 生成预处理后的文件
```

------

### **2. 编译阶段（Compilation）**

**输入**：预处理后的 `.i` 文件 

**输出**：汇编代码文件 `.s`（文本文件）

**工具**：编译器（如 `gcc`、`clang`）

**核心任务**：

1.  **词法分析（Lexical Analysis）**：将代码拆分为**词法单元**（Token），如标识符、关键字、运算符。

2.  **语法分析（Syntax Analysis）**：构建**抽象语法树（AST）**，检查语法是否正确（如括号匹配、语句结构）。

3.  语义分析（Semantic Analysis）

    ：验证语义合理性（如类型检查、作用域规则）。

    

    ```c
    int a = "hello"; // 错误：类型不匹配
    ```

4.  **中间代码生成**：生成中间表示（如 LLVM IR、三地址码），便于优化。

5.  **代码优化**：对中间代码进行优化（如常量折叠、循环展开）。

6.  **生成汇编代码**：将优化后的中间代码转换为目标平台的汇编代码。

**示例**：



```BASH
gcc -S main.i -o main.s  # 生成汇编代码
```

------

### **3. 汇编阶段（Assembly）**

**输入**：汇编代码文件 `.s`
 **输出**：目标文件 `.o` / `.obj`（二进制文件）
 **工具**：汇编器（如 `as`）
 **核心任务**：

-   **将汇编代码转为机器指令**：生成二进制格式的**目标文件**。
-   生成符号表（Symbol Table）：记录代码中的全局变量、函数名等符号及其地址。
    -   符号类型：
        -   **全局符号**：如函数名、全局变量（可被其他文件引用）。
        -   **局部符号**：如静态变量（仅在本文件可见）。

**目标文件结构**（ELF 格式为例）：

-   **代码段（.text）**：存放机器指令。
-   **数据段（.data / .bss）**：存放初始化的全局变量或未初始化的静态变量。
-   **符号表（.symtab）**：记录符号信息。
-   **重定位表（.rel.text / .rel.data）**：标记需要链接时修正的地址。

**示例**：



```BASH
gcc -c main.s -o main.o  # 生成目标文件
```

------

### **4. 链接阶段（Linking）**

**输入**：多个目标文件 `.o` 和库文件 `.a` / `.so`
 **输出**：可执行文件（如 `a.out`）或动态库
 **工具**：链接器（如 `ld`）
 **核心任务**：

1.  符号解析（Symbol Resolution）：
    -   确保每个符号（如函数、全局变量）有且仅有一个定义。
    -   若未找到符号定义，报错 `undefined reference`。
2.  地址重定位（Relocation）：
    -   合并所有目标文件的代码段和数据段。
    -   根据符号的实际地址修正代码中的引用（如函数调用地址）。
3.  处理静态库（Static Libraries）：
    -   将静态库（`.a`）中的目标文件按需链接到可执行文件。
4.  处理动态库（Dynamic Libraries）：
    -   记录动态库（`.so` / `.dll`）的依赖关系，运行时加载。

**链接示例**：



```BASH
gcc main.o utils.o -o app  # 静态链接生成可执行文件
```

------

### **完整流程示例**



```BASH
# 预处理gcc -E main.c -o main.i
# 编译gcc -S main.i -o main.s
# 汇编gcc -c main.s -o main.o
# 链接gcc main.o -o app
```

------

### **关键总结**

| 阶段       | 输入          | 输出          | 核心任务                            |
| ---------- | ------------- | ------------- | ----------------------------------- |
| **预处理** | `.c` / `.cpp` | `.i`          | 处理宏、头文件、条件编译，删除注释  |
| **编译**   | `.i`          | `.s`          | 语法/语义检查，生成优化后的汇编代码 |
| **汇编**   | `.s`          | `.o` / `.obj` | 生成机器码和符号表                  |
| **链接**   | `.o` + 库     | 可执行文件    | 合并代码段、解析符号、地址重定位    |

------

### **常见问题**

1.  **为什么需要符号表？**
     符号表记录全局符号的地址和属性，供链接阶段解析跨文件的符号引用。
2.  **静态链接 vs 动态链接**
    -   **静态链接**：库代码直接嵌入可执行文件，文件较大，但无需依赖外部库。
    -   **动态链接**：运行时加载共享库，节省内存，但依赖环境中的库文件。
3.  **常见错误**
    -   **编译阶段**：语法错误、类型不匹配。
    -   **链接阶段**：未定义的符号、重复定义的符号。