# 22. 反向迭代器2 & 模版进阶

1. 迭代器分类
   - 单向、双向、随机
2. 仿向迭代器针对所有容器

![image-20250606224536697](/Users/youqudezhongguoren/Library/Application Support/typora-user-images/image-20250606224536697.png)

---

1. 非类型模版参数
2. c++ 20 之前只支持 int家族作为非类型模版参数
3. 模版实例化是在编译的时候，函数传参是在运行时
4. 普通数组 越界读不检查 越界写抽查 
   - array 严格检查越界读写
5.  Linux 上栈大概开了 8MB 
6. 模版按需实例化
7. **模版的特化**
   - 日期类比较大小 ---- 仿函数解决
   - 或者特化解决
8. 类模版的特化 
   - 半特化、偏特化
9. 优先级队列 和 Date & Date*



---

1. 模版的分离编译
   - 显示实例化
   - 主要是因为调用的地方虽然知道模版参数实例化成什么类型，但是函数定义的地方是不知道的，所以链接的时候会出错

---







## 🧭 一、迭代器分类及仿函数支持

### 1. 迭代器的五大类（常见分类）

| 类型           | 支持操作                     | 示例容器           |
| -------------- | ---------------------------- | ------------------ |
| 输入迭代器     | 只读，一次性读取             | `istream_iterator` |
| 输出迭代器     | 只写，一次性写入             | `ostream_iterator` |
| 前向迭代器     | 多次读，支持++               | `forward_list`     |
| 双向迭代器     | 支持++ 和 --                 | `list`, `set`      |
| 随机访问迭代器 | 支持 [], +n, -n, <, > 等操作 | `vector`, `deque`  |

> **单向**：只能++（如`forward_list`）
>  **双向**：能++和--（如`list`）
>  **随机访问**：类似数组，可跳跃访问（如`vector`）

### 2. 仿函数与容器适配

- STL 容器（如 `set`, `map`, `priority_queue`）可以通过传入 **仿函数（函数对象）** 来定制排序规则。
- 例如用于 `set<Date, MyCmp>`，其中 `MyCmp` 是重载了 `operator()` 的类。

------

## 🧩 二、模板机制与扩展知识

### 1. 非类型模板参数（NTTP）

```cpp
template<int N>
void printNTimes() {
    for (int i = 0; i < N; ++i) cout << "Hello\n";
}
```

### 2. C++20 前的限制

- 非类型模板参数只支持**整型家族类型**：`int`, `char`, `bool`, `enum`, `nullptr_t` 等。
- C++20 开始支持 `const char*`, `std::integral_constant` 等更多复杂类型。

### 3. 模板实例化 vs 函数调用

| 特性     | 模板实例化          | 函数调用    |
| -------- | ------------------- | ----------- |
| 发生时机 | 编译期              | 运行期      |
| 目的     | 生成具体函数/类代码 | 执行逻辑    |
| 示例     | `add<int>()`        | `add(1, 2)` |



### 4. 普通数组 vs `std::array`

- **C 风格数组**
  - 越界读写行为未定义
  - 编译器不做边界检查
- **`std::array`**
  - 提供 `.at()` 方法：**会检查越界，抛出异常**
  - `[]` 不检查（和数组一样）

### 5. 栈大小（Linux）

- 通常默认栈大小为 **8MB**。
- 可用 `ulimit -s` 查看/修改。

### 6. 模板按需实例化（懒实例化）

- 模板只有在**被使用**时，才会实例化具体类型。
- 避免了冗余代码生成。

------

## 🎯 三、模板特化与 Date 类例子

### 7. 模板特化

#### 用途：解决通用模板无法处理的特定类型

```cpp
template<typename T>
bool isZero(T t) { return t == 0; }

template<>
bool isZero<string>(string s) { return s.empty(); }
```

- 通常用在 STL 容器中定制某些行为。

#### `Date` 类比较

- 两种做法：
  1. **定义仿函数 `DateCmp`**，用于容器排序。
  2. **特化模板**（如 `std::less<Date>`）

### 8. 类模板的特化

#### 全特化

```cpp
template<>
class MyClass<int> { ... };
```

#### 偏特化（Partial Specialization）

```cpp
template<typename T>
class MyClass<T*> { ... };
```

#### 示例用途：

- 对 `指针类型`、`数组类型`、`特定类型` 实现不同行为。

------

## 🧱 四、其他重要概念

### 9. 优先级队列与 `Date`

```cpp
priority_queue<Date, vector<Date>, DateCmp>
priority_queue<Date*, vector<Date*>, DatePtrCmp>
```

- 注意：对于指针类型（如 `Date*`），需要特别注意比较函数。
- 因为默认是比地址大小，**通常需写自定义比较器**来按对象内容比较。

------

## 🔧 五、模板的分离编译

### 问题：

- 模板定义通常在头文件中，否则链接时找不到实例化代码。

### 解决方法：

#### 显式实例化声明 `.h`

```cpp
extern template class MyClass<int>;
```

#### 显式实例化定义 `.cpp`

```cpp
template class MyClass<int>;
```

### 原因：

- 因为模板实例化发生在**使用处**，定义处无法预知具体类型。
- 所以需要告诉编译器提前生成某些类型的实例化代码，防止链接错误。