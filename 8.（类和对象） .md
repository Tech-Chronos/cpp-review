## **4.16 -8 本节知识点 `list`**

1.    **流插入 连续插入重载 ，连续赋值（赋值重载）**

2.    const 成员函数

3.    权限的放大要看会不会对 本身造成影响 例如引用和指针

4.   取地址重载 一般给假地址会用，正常不会用，用编译器自己实现的就可以了

5.    初始化列表

     -   初始化列表的顺序和 生命顺序 有关

     -   任何成员变量都会先走初始化列表，这是成员变量首次被定义的地方，所以const，引用必须走初始化列表，以及没有默认构造的自定义类型
     -   缺省值给初始化列表用的

6.    C cc2 = 2;  构造 + 拷贝构造

     -   const C& cc3 = 3

7.    explicit

8.   c++11 支持 多参数隐式类型转换 花括号

9.    静态不能给缺省值 属于整个类的，不属于对象，要在类外定义

10.    静态成员函数 可以用 类名访问，因为属于类，没有this 指针

---

## **1. 流插入运算符（`<<`）重载与连续赋值**

-   **流插入运算符重载**
     需返回`ostream&`以实现链式调用（连续插入）：

```cpp
ostream& operator<<(ostream& out, const T& obj) 
{ 
  out << obj.data; 
  return out; 
}
```

-   **连续赋值（赋值运算符重载）**

​		需返回当前对象的引用以支持链式赋值（如`a = b = c`）：

```cpp
T& operator=(const T& other) 
{ 
  // 赋值逻辑
  return *this; 
}
```

---

## **2. `const`成员函数**

-   **作用**：标记为`const`的成员函数不可修改对象成员变量（除非变量被`mutable`修饰）。

-   用法：

    

    ```cpp
    class C 
    {
    public:  
        int getValue() const // 常函数
        { 
            return value; 
        } 
    private:  
        int value;
    };
    ```

-   **调用场景**：只能被`const`对象调用，非`const`对象也可调用**（优先选择非`const`版本）**。

------

## **3. 权限放大与引用/指针**

-   权限放大：将低权限对象（如`const`）转换为高权限引用/指针会报错。

    

    ```cpp
    const int a = 10;
    int& b = a;        // 错误：权限放大（去除了const）
    const int& c = a;  // 正确：权限不变
    ```

---

## **4. 取地址运算符重载**

-   **用途**：极少使用，一般返回假地址用于特殊场景（如对象池管理）。

-   注意：默认使用编译器生成的`operator&`即可，重载可能导致意外行为。

    

    ```cpp
    class C 
    {
    public:
      C* operator&() { return nullptr; } // 返回假地址（不推荐）
    };
    ```

---

## **5. 初始化列表**

#### **（1）初始化顺序与成员声明顺序**

-   **核心规则**：成员变量的初始化顺序**严格遵循类中声明的顺序**，与初始化列表中的书写顺序无关。
-   **潜在风险**：若初始化列表中顺序与声明顺序不一致，可能导致依赖错误。

**示例**：

```cpp
class Test 
{
public:
    Test(int a) 
        : b(a), a(b) 
    {} // 错误：a 先于 b 初始化，但试图用未初始化的 b 初始化 a
private:
    int a;
    int b;
};
```

-   **解释**：根据声明顺序，`a` 先初始化，此时使用未初始化的 `b` 赋值给 `a`，导致未定义行为。

#### **（2）必须使用初始化列表的情况**

以下成员变量**必须**在初始化列表中显式初始化：

1.  **`const` 成员变量**
     常量必须在定义时初始化，无法在构造函数体内赋值。

    

    ```cpp
    class C 
    {
    public:
        C(int x) 
            : value(x) 
        {} // 正确：const成员必须通过初始化列表赋值
    private:
        const int value;
    };
    ```

2.  **引用成员变量**
     引用必须在定义时绑定到一个对象，无法重新绑定。

    

    ```cpp
    class C 
    {
    public:
        C(int& ref) 
            : ref_member(ref) 
        {} // 正确：引用必须通过初始化列表绑定
    private:
        int& ref_member;
    };
    ```

3.  **无默认构造函数的自定义类型成员**
     若成员对象的类没有默认构造函数，必须通过初始化列表显式调用其有参构造函数。

    

    ```cpp
    class A 
    {
    public:
        A(int x) {} // 没有默认构造函数
    };
    
    class B 
    {
    public:
        B(int x) 
            : a(x) 
        {} // 正确：显式调用 A 的构造函数
    private:
        A a; // 错误：若未在初始化列表中初始化，编译器无法调用默认构造
    };
    ```

#### **（3）成员变量的首次定义**

-   **初始化列表是成员变量首次被定义的地方**，构造函数体内是赋值操作。

-   代码对比：

    <CPP>

    ```cpp
    class C 
    {
    public:
        C(int x) 
        {
            value = x; // 此处是赋值，而非初始化
        }
    private:
        int value;
    };
    ```

    

    ```cpp
    class C 
    {
    public:
        C(int x) : value(x) {} // 此处是初始化
    private:
        int value;
    };
    ```

#### **（4）缺省值与初始化列表的关系**

-   若成员变量在初始化列表中未被显式初始化，则使用类内提供的缺省值。
-   若既无初始化列表赋值也无缺省值，则内置类型为随机值，自定义类型调用默认构造函数。

**示例**：

```cpp
class C 
{
public:
    C() {} // a 使用缺省值 10，b 使用缺省值 20
    C(int x) 
        : a(x) 
    {} // a=x，b=20
private:
    int a = 10; // 类内缺省值
    int b = 20;
};
```



---

## **6. 隐式类型转换与对象构造**

#### **（1）`C cc2 = 2;` 的执行过程**

-   隐式转换流程：
    1.  编译器尝试将 `2` 转换为 `C` 类型的临时对象，调用 `C(int)` 构造函数。
    2.  使用临时对象调用拷贝构造函数（理论上），生成 `cc2`。
-   **编译器优化（拷贝省略）**：
    实际编译时，编译器会直接调用构造函数生成 `cc2`，跳过了拷贝构造步骤（即使拷贝构造函数是私有的，此代码仍可通过编译）。

**示例**：

```cpp
class C 
{
public:
    C(int x) 
    { 
        cout << "Constructor" << endl; 
    }
    C(const C& other) 
    { 
        cout << "Copy Constructor" << endl; 
    }
};

int main() 
{
    C cc2 = 2; // 输出 "Constructor"，无拷贝构造
    return 0;
}
```

#### **（2）`const C& cc3 = 3;` 的执行过程**

-   隐式转换流程：
    1.  编译器生成临时对象 `C(3)`。
    2.  将临时对象绑定到常引用 `cc3`。
-   **生命周期延长规则**：
    **临时对象的生命周期被延长至引用 `cc3` 的作用域结束，避免悬垂引用。**

**示例**：



```cpp
class C 
{
public:
    C(int x) 
    { 
        cout << "Constructor" << endl; 
    }
    ~C() 
    { 
        cout << "Destructor" << endl;
    }
};

int main() 
{
    {
        const C& cc3 = 3; // 输出 "Constructor"
    } // 输出 "Destructor"（临时对象在此处销毁）
    return 0;
}
```

#### **（3）关键注意事项**

1.  **权限限制**：
     非 `const` 引用无法绑定到临时对象（权限放大）：

    

    ```cpp
    C& r = 5; // 错误：临时对象不能绑定到非 const 引用
    const C& cr = 5; // 正确
    ```

2.  **`explicit` 的影响**：
     若构造函数被标记为 `explicit`，则禁止隐式转换：

    

    ```cpp
    class C 
    {
    public:
        explicit C(int x) {}
    };
    
    C cc2 = 2; // 错误：无法隐式转换
    C cc3(2);  // 正确：显式构造
    ```

---

## **7. `explicit`关键字**

-   **作用**：禁止隐式类型转换，仅允许显式构造。

```c++
class C 
{
public:
  explicit C(int x) {} // 必须显式调用构造函数
};

C c1 = 10;    // 错误：隐式转换被禁止
C c2(10);     // 正确：显式构造
C c3 = C(10); // 正确：显式构造
```

---

## **8. C++11多参数隐式类型转换**

-   花括号初始化：支持多参数隐式构造（需构造函数未标记explicit）。

    

    ```cpp
    class C 
    {
    public:
      C(int x, int y) {} // 非 explicit
    };
    
    C c = {1, 2}; // 隐式调用构造函数
    ```

---

## **9. 静态成员变量**

-   类内声明，类外定义：**静态成员属于类而非对象，需在类外分配内存**。

    

    ```cpp
    class C 
    {
    public:
      static int count; // 类内声明
    };
    int C::count = 0;   // 类外定义
    ```

-   例外：`const static` 整型或枚举类型可在类内初始化：

    

    ```cpp
    class C 
    {
    public:
      const static int MAX = 100; // 允许类内初始化
    };
    ```

---

## **10. 静态成员函数**

-   特性：

    -   属于类而非对象，通过类名直接调用：`C::func();`
    -   无`this`指针，只能访问静态成员变量。

    

    ```cpp
    class C 
    {
    public:
      static void print() 
      { 
        cout << count; // 正确：访问静态成员
        // cout << value; // 错误：无法访问非静态成员
      }
      static int count;
      int value;
    };
    ```

---

------

## **总结表格**

| **知识点**       | **核心要点**                                           |
| ---------------- | ------------------------------------------------------ |
| 流插入与连续赋值 | 返回引用以支持链式调用                                 |
| `const`成员函数  | 不可修改成员变量，`const`对象专用                      |
| 权限放大         | 避免`const`引用/指针转换为非`const`                    |
| 取地址重载       | 一般不重载，保留默认行为                               |
| 初始化列表       | 顺序按声明顺序，`const`/引用/无默认构造必须使用        |
| 隐式类型转换     | `explicit`禁止隐式转换，C++11支持多参数花括号初始化    |
| 静态成员         | 类外定义（除`const static`整型），静态函数无`this`指针 |